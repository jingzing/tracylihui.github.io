
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>设计模式：处理多维度变化——桥接模式 | 李大辉</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Ｔracylihui">
    

    
    <meta name="description" content="桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】
该博文是转载LoveLion的博客，在其基础上，将HTML改写为Markdown。在原博文中，作者已经给每个模式都设计了一个实现代码，我已经将代码全部实现，做了一定修改放到了Github中，大家可以clone看一下实现效果，加强印象。Github地址：https://github.com/tracylihui/d">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式：处理多维度变化——桥接模式">
<meta property="og:url" content="http://yoursite.com/2015/07/25/designPattern/设计模式：处理多维度变化——桥接模式/index.html">
<meta property="og:site_name" content="李大辉">
<meta property="og:description" content="桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】
该博文是转载LoveLion的博客，在其基础上，将HTML改写为Markdown。在原博文中，作者已经给每个模式都设计了一个实现代码，我已经将代码全部实现，做了一定修改放到了Github中，大家可以clone看一下实现效果，加强印象。Github地址：https://github.com/tracylihui/d">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge1.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge2.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge3.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge4.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge5.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge6.gif">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge7.jpg">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge8.jpg">
<meta property="og:image" content="http://7xk5ao.com1.z0.glb.clouddn.com/bridge9.jpg">
<meta property="og:updated_time" content="2015-07-26T04:59:40.987Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式：处理多维度变化——桥接模式">
<meta name="twitter:description" content="桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】
该博文是转载LoveLion的博客，在其基础上，将HTML改写为Markdown。在原博文中，作者已经给每个模式都设计了一个实现代码，我已经将代码全部实现，做了一定修改放到了Github中，大家可以clone看一下实现效果，加强印象。Github地址：https://github.com/tracylihui/d">

    
    <link rel="alternative" href="/atom.xml" title="李大辉" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="李大辉" title="李大辉"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="李大辉">李大辉</a></h1>
				<h2 class="blog-motto">给自己提供一个总结的平台</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/summary">知识点总结</a></li>
					
						<li><a href="/problems">Bug汇总</a></li>
					
						<li><a href="/archives">文章</a></li>
					
						<li><a href="/about">简历</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/25/designPattern/设计模式：处理多维度变化——桥接模式/" title="设计模式：处理多维度变化——桥接模式" itemprop="url">设计模式：处理多维度变化——桥接模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Ｔracylihui" target="_blank" itemprop="author">Ｔracylihui</a>
		
  <p class="article-time">
    <time datetime="2015-07-25T13:00:03.000Z" itemprop="datePublished"> 发表于 2015-07-25</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#跨平台图像浏览系统"><span class="toc-number">1.</span> <span class="toc-text">跨平台图像浏览系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式概述"><span class="toc-number">2.</span> <span class="toc-text">桥接模式概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完整解决方案"><span class="toc-number">3.</span> <span class="toc-text">完整解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#适配器模式与桥接模式的联用"><span class="toc-number">4.</span> <span class="toc-text">适配器模式与桥接模式的联用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#典型例子-JDBC"><span class="toc-number">5.</span> <span class="toc-text">典型例子-JDBC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式总结"><span class="toc-number">6.</span> <span class="toc-text">桥接模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要优点"><span class="toc-number">6.1.</span> <span class="toc-text">主要优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主要缺点"><span class="toc-number">6.2.</span> <span class="toc-text">主要缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适用场景"><span class="toc-number">6.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol>
		
		</div>
		
		<p>桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】</p>
<p>该博文是转载LoveLion的博客，在其基础上，将HTML改写为Markdown。在原博文中，作者已经给每个模式都设计了一个实现代码，我已经将代码全部实现，做了一定修改放到了Github中，大家可以clone看一下实现效果，加强印象。<br>Github地址：<a href="https://github.com/tracylihui/design_pattern" target="_blank" rel="external">https://github.com/tracylihui/design_pattern</a><br>原文链接：<a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">史上最全设计模式导学目录（完整版）</a></p>
<p>在正式介绍桥接模式之前，我先跟大家谈谈两种常见文具的区别，它们是毛笔和蜡笔。假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔需增加12支，而毛笔只需增加一支。为什么会这样呢？通过分析我们可以得知：在蜡笔中，颜色和型号两个不同的变化维度（即两个不同的变化原因）融合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方都没有任何影响。如果使用软件工程中的术语，我们可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也更为方便。在软件开发中，我们也提供了一种设计模式来处理与画笔类似的具有多变化维度的情况，即本章将要介绍的桥接模式。<br><a id="more"></a></p>
<h1 id="跨平台图像浏览系统">跨平台图像浏览系统</h1><hr>
<p>Sunny软件公司欲开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，并且能够在Windows、Linux、Unix等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵(Matrix)，然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。系统需具有较好的扩展性以支持新的文件格式和操作系统。</p>
<p>Sunny软件公司的开发人员针对上述要求，提出了一个初始设计方案，其基本结构如图10-1所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge1.gif" alt=""><br>在图10-1的初始设计方案中，使用了一种多层继承结构，Image是抽象父类，而每一种类型的图像类，如BMPImage、JPGImage等作为其直接子类，不同的图像文件格式具有不同的解析方法，可以得到不同的像素矩阵；由于每一种图像又需要在不同的操作系统中显示，不同的操作系统在屏幕上显示像素矩阵有所差异，因此需要为不同的图像类再提供一组在不同操作系统显示的子类，如为BMPImage提供三个子类BMPWindowsImp、BMPLinuxImp和BMPUnixImp，分别用于在Windows、Linux和Unix三个不同的操作系统下显示图像。</p>
<p>我们现在对该设计方案进行分析，发现存在如下两个主要问题：</p>
<ol>
<li>由于采用了多层继承结构，导致系统中类的个数急剧增加，图10-1中，在各种图像的操作系统实现层提供了12个具体类，加上各级抽象层的类，系统中类的总个数达到了17个，在该设计方案中，具体层的类的个数 = 所支持的图像文件格式数×所支持的操作系统数。</li>
<li>系统扩展麻烦，由于每一个具体类既包含图像文件格式信息，又包含操作系统信息，因此无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，例如在图10-1中增加一种新的图像文件格式TIF，则需要增加3个具体类来实现该格式图像在3种不同操作系统的显示；如果增加一个新的操作系统Mac OS，为了在该操作系统下能够显示各种类型的图像，需要增加4个具体类。这将导致系统变得非常庞大，增加运行和维护开销。</li>
</ol>
<p>如何解决这两个问题？我们通过分析可得知，该系统存在两个独立变化的维度：图像文件格式和操作系统，如图10-2所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge2.gif" alt=""><br>在图10-2中，如何将各种不同类型的图像文件解析为像素矩阵与图像文件格式本身相关，而如何在屏幕上显示像素矩阵则仅与操作系统相关。正因为图10-1所示结构将这两种职责集中在一个类中，导致系统扩展麻烦，从类的设计角度分析，具体类BMPWindowsImp、BMPLinuxImp和BMPUnixImp等违反了“单一职责原则”，因为不止一个引起它们变化的原因，它们将图像文件解析和像素矩阵显示这两种完全不同的职责融合在一起，任意一个职责发生改变都需要修改它们，系统扩展困难。</p>
<p>如何改进？我们的方案是将图像文件格式（对应<strong>图像格式的解析</strong>）与操作系统（对应<strong>像素矩阵的显示</strong>）两个维度分离，使得它们可以独立变化，增加新的图像文件格式或者操作系统时都对另一个维度不造成任何影响。看到这里，大家可能会问，到底如何在软件中实现将两个维度分离呢？不用着急，本章我将为大家详细介绍一种用于处理多维度变化的设计模式——桥接模式。</p>
<h1 id="桥接模式概述">桥接模式概述</h1><hr>
<p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p>
<p>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。桥接定义如下：<br><strong>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</strong></p>
<p>桥接模式的结构与其名称一样，存在一条连接两个继承等级结构的桥，桥接模式结构如图10-3所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge3.gif" alt=""><br>在桥接模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Abstraction（抽象类）</strong>：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li>
<li><strong>RefinedAbstraction（扩充抽象类）</strong>：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</li>
<li><strong>Implementor（实现类接口）</strong>：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</li>
<li><strong>ConcreteImplementor（具体实现类）</strong>：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li>
</ul>
<p>桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。</p>
<p>在使用桥接模式时，我们首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此我们可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。在此，<strong>型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分</strong>，结构示意图如图10-4所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge4.gif" alt=""></p>
<p>在图10-4中，如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。</p>
<p>在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了使两者之间耦合度降低，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实现Implementor接口的子类中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法。</p>
<p>对于另一“抽象部分”维度而言，其典型的抽象类代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> Implementor impl; <span class="comment">//定义实现类接口对象  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(Implementor impl)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.impl=impl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;  <span class="comment">//声明抽象业务方法  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过注入的方式给该对象赋值，一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充抽象类或细化抽象类(RefinedAbstraction)，典型的RefinedAbstraction类代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//业务代码  </span></span><br><span class="line">        impl.operationImpl();  <span class="comment">//调用实现类的方法  </span></span><br><span class="line">        <span class="comment">//业务代码  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。</p>
<h1 id="完整解决方案">完整解决方案</h1><hr>
<p>为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图10-5所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge5.gif" alt=""><br>在图10-5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；ImageImp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。完整代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像素矩阵类：辅助类，各种格式的文件最终都被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//此处代码省略  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象图像类：抽象类  </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> ImageImp imp;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageImp</span><span class="params">(ImageImp imp)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.imp = imp;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象操作系统实现类：实现类接口  </span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ImageImp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span></span>;  <span class="comment">//显示像素矩阵m  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows操作系统实现类：具体实现类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowsImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//调用Windows系统的绘制函数绘制像素矩阵  </span></span><br><span class="line">        System.out.print(<span class="string">"在Windows操作系统中显示图像："</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Linux操作系统实现类：具体实现类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinuxImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//调用Linux系统的绘制函数绘制像素矩阵  </span></span><br><span class="line">        System.out.print(<span class="string">"在Linux操作系统中显示图像："</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Unix操作系统实现类：具体实现类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnixImp</span> <span class="keyword">implements</span> <span class="title">ImageImp</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPaint</span><span class="params">(Matrix m)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//调用Unix系统的绘制函数绘制像素矩阵  </span></span><br><span class="line">        System.out.print(<span class="string">"在Unix操作系统中显示图像："</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//JPG格式图像：扩充抽象类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//模拟解析JPG文件并获得一个像素矩阵对象m;  </span></span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);  </span><br><span class="line">        System.out.println(fileName + <span class="string">"，格式为JPG。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//PNG格式图像：扩充抽象类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PNGImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//模拟解析PNG文件并获得一个像素矩阵对象m;  </span></span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);  </span><br><span class="line">        System.out.println(fileName + <span class="string">"，格式为PNG。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//BMP格式图像：扩充抽象类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMPImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//模拟解析BMP文件并获得一个像素矩阵对象m;  </span></span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);  </span><br><span class="line">        System.out.println(fileName + <span class="string">"，格式为BMP。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//GIF格式图像：扩充抽象类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GIFImage</span> <span class="keyword">extends</span> <span class="title">Image</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseFile</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//模拟解析GIF文件并获得一个像素矩阵对象m;  </span></span><br><span class="line">        Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">        imp.doPaint(m);  </span><br><span class="line">        System.out.println(fileName + <span class="string">"，格式为GIF。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了让系统具有更好的灵活性和可扩展性，我们引入了配置文件，将具体扩充抽象类和具体实现类类名都存储在配置文件中，再通过反射生成对象，将生成的具体实现类对象注入到扩充抽象类对象中，其中，配置文件config.xml的代码如下所示：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">config</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--RefinedAbstraction--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">className</span>&gt;</span>JPGImage<span class="tag">&lt;/<span class="title">className</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ConcreteImplementor--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">className</span>&gt;</span>WindowsImp<span class="tag">&lt;/<span class="title">className</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">config</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用于读取配置文件config.xml并反射生成对象的XMLUtil类的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.parsers.*;  </span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.*;  </span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;  </span><br><span class="line"><span class="keyword">import</span> java.io.*;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLUtil</span> </span>&#123;  </span><br><span class="line"><span class="comment">//该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//创建文档对象  </span></span><br><span class="line">            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();  </span><br><span class="line">            DocumentBuilder builder = dFactory.newDocumentBuilder();  </span><br><span class="line">            Document doc;</span><br><span class="line">            doc = builder.parse(<span class="keyword">new</span> File(<span class="string">"config.xml"</span>));</span><br><span class="line">            NodeList nl=<span class="keyword">null</span>;  </span><br><span class="line">            Node classNode=<span class="keyword">null</span>;  </span><br><span class="line">            String cName=<span class="keyword">null</span>;  </span><br><span class="line">            nl = doc.getElementsByTagName(<span class="string">"className"</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(args.equals(<span class="string">"image"</span>)) &#123;  </span><br><span class="line">                <span class="comment">//获取第一个包含类名的节点，即扩充抽象类  </span></span><br><span class="line">                classNode=nl.item(<span class="number">0</span>).getFirstChild();  </span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(args.equals(<span class="string">"os"</span>)) &#123;  </span><br><span class="line">               <span class="comment">//获取第二个包含类名的节点，即具体实现类  </span></span><br><span class="line">                classNode=nl.item(<span class="number">1</span>).getFirstChild();  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">             cName=classNode.getNodeValue();  </span><br><span class="line">             <span class="comment">//通过类名生成实例对象并将其返回  </span></span><br><span class="line">             Class c=Class.forName(cName);  </span><br><span class="line">             Object obj=c.newInstance();  </span><br><span class="line">             <span class="keyword">return</span> obj;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span>(Exception e) &#123;  </span><br><span class="line">              e.printStackTrace();  </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写如下客户端测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </span><br><span class="line">        Image image;  </span><br><span class="line">        ImageImp imp;  </span><br><span class="line">        image = (Image)XMLUtil.getBean(<span class="string">"image"</span>);  </span><br><span class="line">        imp = (ImageImp)XMLUtil.getBean(<span class="string">"os"</span>);  </span><br><span class="line">        image.setImageImp(imp);  </span><br><span class="line">        image.parseFile(<span class="string">"小龙女"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行程序，输出结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Windows操作系统中显示图像：小龙女，格式为JPG。</span><br></pre></td></tr></table></figure></p>
<p>如果需要更换图像文件格式或者更换操作系统，只需修改配置文件即可，在实际使用时，<strong>可以通过分析图像文件格式后缀名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型</strong>，无须使用配置文件。当增加新的图像文件格式或者操作系统时，原有系统无须做任何修改，只需增加一个对应的扩充抽象类或具体实现类即可，系统具有较好的可扩展性，完全符合“开闭原则”。</p>
<h1 id="适配器模式与桥接模式的联用">适配器模式与桥接模式的联用</h1><hr>
<p>在软件开发中，适配器模式通常可以与桥接模式联合使用。适配器模式可以解决两个已有接口间不兼容问题，在这种情况下被适配的类往往是一个黑盒子，有时候我们不想也不能改变这个被适配的类，也不能控制其扩展。适配器模式通常用于现有系统与第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式来对系统进行扩展。</p>
<p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p>
<p>下面通过一个实例来说明适配器模式和桥接模式的联合使用：</p>
<p>在某系统的报表处理模块中，需要将报表显示和数据采集分开，系统可以有多种报表显示方式也可以有多种数据采集方式，如可以从文本文件中读取数据，也可以从数据库中读取数据，还可以从Excel文件中获取数据。如果需要从Excel文件中获取数据，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。使用适配器模式和桥接模式设计该模块。</p>
<p>在设计过程中，由于存在报表显示和数据采集两个独立变化的维度，因此可以使用桥接模式进行初步设计；为了使用Excel相关的API来进行数据采集则需要使用适配器模式。系统的完整设计中需要将两个模式联用，如图10-6所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge6.gif" alt=""></p>
<h1 id="典型例子-JDBC">典型例子-JDBC</h1><hr>
<p>该例子并不是原文章中提供了，而是我自己加上为了更好的理解桥接模式。<br>以下内容摘抄于：<a href="http://www.oschina.net/question/1435262_140274#tags_nav" target="_blank" rel="external">研磨设计模式 之 桥接模式（Bridge）</a></p>
<p>在Java应用中，对于桥接模式有一个非常典型的例子，就是：应用程序使用JDBC驱动程序进行开发的方式。所谓驱动程序，指的是按照预先约定好的接口来操作计算机系统或者是外围设备的程序。</p>
<p>先简单的回忆一下使用JDBC进行开发的过程，简单的片断代码示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"具体要操作的sql语句"</span>;</span><br><span class="line"><span class="comment">// 1：装载驱动</span></span><br><span class="line">Class.forName(<span class="string">"驱动的名字"</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"连接数据库服务的URL"</span>, <span class="string">"用户名"</span>,<span class="string">"密码"</span>);</span><br><span class="line"><span class="comment">// 3：创建statement或者是preparedStatement</span></span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 4：执行sql，如果是查询，再获取ResultSet</span></span><br><span class="line">ResultSet rs = pstmt.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line"><span class="comment">// 取值示意，按名称取值</span></span><br><span class="line">String uuid = rs.getString(<span class="string">"uuid"</span>);</span><br><span class="line"><span class="comment">// 取值示意，按索引取值</span></span><br><span class="line"><span class="keyword">int</span> age = rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6：关闭</span></span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></p>
<p>从上面的示例可以看出，我们写的应用程序，是面向JDBC的API在开发，这些接口就相当于桥接模式中的抽象部分的接口。那么怎样得到这些API的呢？是通过DriverManager来得到的。此时的系统结构如图7所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge7.jpg" alt="图7 基于JDBC开发的应用程序结构示意图"><br>那么这些JDBC的API，谁去实现呢？光有接口，没有实现也不行啊。</p>
<p>该驱动程序登场了，JDBC的驱动程序实现了JDBC的API，驱动程序就相当于桥接模式中的具体实现部分。而且不同的数据库，由于数据库实现不一样，可执行的Sql也不完全一样，因此对于JDBC驱动的实现也是不一样的，也就是不同的数据库会有不同的驱动实现。此时驱动程序这边的程序结构如图8所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge8.jpg" alt="图8 驱动程序实现结构示意图"><br>有了抽象部分——JDBC的API，有了具体实现部分——驱动程序，那么它们如何连接起来呢？就是如何桥接呢？</p>
<p>就是前面提到的DriverManager来把它们桥接起来，从某个侧面来看，DriverManager在这里起到了类似于简单工厂的功能，基于JDBC的应用程序需要使用JDBC的API，如何得到呢？就通过DriverManager来获取相应的对象。</p>
<p>那么此时系统的整体结构如图9所示：<br><img src="http://7xk5ao.com1.z0.glb.clouddn.com/bridge9.jpg" alt="图9 JDBC的结构示意图"></p>
<p>通过上图可以看出，基于JDBC的应用程序，使用JDBC的API，相当于是对数据库操作的抽象的扩展，算作桥接模式的抽象部分；而具体的接口实现是由驱动来完成的，驱动这边自然就相当于桥接模式的实现部分了。而桥接的方式，不再是让抽象部分持有实现部分，而是采用了类似于工厂的做法，通过DriverManager来把抽象部分和实现部分对接起来，从而实现抽象部分和实现部分解耦。</p>
<p>JDBC的这种架构，把抽象和具体分离开来，从而使得抽象和具体部分都可以独立扩展。对于应用程序而言，只要选用不同的驱动，就可以让程序操作不同的数据库，而无需更改应用程序，从而实现在不同的数据库上移植；对于驱动程序而言，为数据库实现不同的驱动程序，并不会影响应用程序。而且，JDBC的这种架构，还合理的划分了应用程序开发人员和驱动程序开发人员的边界。</p>
<p>对于有些朋友会认为，从局部来看，体现了策略模式，比如在上面的结构中去掉“JDBC的API和基于JDBC的应用程序”这边，那么剩下的部分，看起来就是一个策略模式的体现。此时的DriverManager就相当于上下文，而各个具体驱动的实现就相当于是具体的策略实现，这个理解也不算错，但是在这里看来，这么理解是比较片面的。</p>
<p>对于这个问题，再次强调一点：对于设计模式，要从整体结构上、从本质目标上、从思想体现上来把握，而不要从局部、从表现、从特例实现上来把握。</p>
<h1 id="桥接模式总结">桥接模式总结</h1><hr>
<p>桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。在软件开发中如果一个类或一个系统有多个变化维度时，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p>
<h2 id="主要优点">主要优点</h2><p>桥接模式的主要优点如下：</p>
<ol>
<li>分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</li>
<li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</li>
<li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</li>
</ol>
<h2 id="主要缺点">主要缺点</h2><p>桥接模式的主要缺点如下：</p>
<ol>
<li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li>
</ol>
<h2 id="适用场景">适用场景</h2><p>在以下情况下可以考虑使用桥接模式：</p>
<ol>
<li>如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li>
<li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/设计模式/">设计模式</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2015/07/25/designPattern/设计模式：处理多维度变化——桥接模式/" data-title="设计模式：处理多维度变化——桥接模式 | 李大辉" data-tsina="1901372893" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/07/25/designPattern/设计模式：树形结构的处理——组合模式/" title="设计模式：树形结构的处理——组合模式">
  <strong>上一篇：</strong><br/>
  <span>
  设计模式：树形结构的处理——组合模式</span>
</a>
</div>


<div class="next">
<a href="/2015/07/24/designPattern/设计模式：不兼容结构的协调——适配器模式/"  title="设计模式：不兼容结构的协调——适配器模式">
 <strong>下一篇：</strong><br/> 
 <span>设计模式：不兼容结构的协调——适配器模式
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/07/25/designPattern/设计模式：处理多维度变化——桥接模式/" data-title="设计模式：处理多维度变化——桥接模式" data-url="http://yoursite.com/2015/07/25/designPattern/设计模式：处理多维度变化——桥接模式/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#跨平台图像浏览系统"><span class="toc-number">1.</span> <span class="toc-text">跨平台图像浏览系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式概述"><span class="toc-number">2.</span> <span class="toc-text">桥接模式概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#完整解决方案"><span class="toc-number">3.</span> <span class="toc-text">完整解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#适配器模式与桥接模式的联用"><span class="toc-number">4.</span> <span class="toc-text">适配器模式与桥接模式的联用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#典型例子-JDBC"><span class="toc-number">5.</span> <span class="toc-text">典型例子-JDBC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#桥接模式总结"><span class="toc-number">6.</span> <span class="toc-text">桥接模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要优点"><span class="toc-number">6.1.</span> <span class="toc-text">主要优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主要缺点"><span class="toc-number">6.2.</span> <span class="toc-text">主要缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#适用场景"><span class="toc-number">6.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Hibernate/" title="Hibernate">Hibernate<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java集合/" title="Java集合">Java集合<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Junit/" title="Junit">Junit<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Maven/" title="Maven">Maven<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/RESTful/" title="RESTful">RESTful<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/SpringMVC/" title="SpringMVC">SpringMVC<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/密码加密/" title="密码加密">密码加密<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>12</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Java集合/" title="Java集合">Java集合<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/关系映射/" title="关系映射">关系映射<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/JVM/" title="JVM">JVM<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/检索策略/" title="检索策略">检索策略<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/AOP/" title="AOP">AOP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/事务/" title="事务">事务<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringMVC/" title="SpringMVC">SpringMVC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/加密/" title="加密">加密<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/加盐/" title="加盐">加盐<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内存泄漏/" title="内存泄漏">内存泄漏<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/RESTful/" title="RESTful">RESTful<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据库/" title="数据库">数据库<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mysql/" title="Mysql">Mysql<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Junit/" title="Junit">Junit<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mocks/" title="Mocks">Mocks<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Stubs/" title="Stubs">Stubs<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.csdn.net/tracyhuixingfu一个面向程序员交流分享的新一代社区" target="_blank" title="李辉的CSDN博客">李辉的CSDN博客</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/tracylihui" target="_blank" title="Github">Github</a>
            
          </li>
        
          <li>
            
            	<a href="http://tmaczhao.cn/" target="_blank" title="Drm.for PMonkey">Drm.for PMonkey</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1901372893&verifier=cbe23457&dpc=1"></iframe>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m a little programmer. <br/>
			But I believe I can change the world.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1901372893" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/tracylihui" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="Ｔracylihui">Ｔracylihui</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"lihui"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F03a3d7014b8737cea96d5197e4ac5fd0' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
